import 'package:fantom/src/generator/components/component/generated_components.dart';
import 'package:fantom/src/generator/components/components_registrey.dart';
import 'package:fantom/src/generator/schema/schema_class_generator.dart';
import 'package:fantom/src/generator/schema/schema_from_json_generator.dart';
import 'package:fantom/src/generator/schema/schema_to_json_generator.dart';
import 'package:fantom/src/mediator/mediator/schema/schema_mediator.dart';
import 'package:fantom/src/mediator/model/schema/schema_model.dart';
import 'package:fantom/src/reader/model/model.dart';
import 'package:fantom/src/utils/logger.dart';
import 'package:recase/recase.dart';
import 'package:sealed_writer/sealed_writer.dart';

typedef Content = Map<String, MediaType>;

/// is a ManifestGenerator that creates objects that can be used by ComponentGenerators to generate components
///
/// NOTE: an openapi content object in our sdk is represented by a Map<String, MediaType>
class ContentManifestCreator {
  ContentManifestCreator({
    required this.openApi,
    required this.schemaMediator,
    required this.schemaClassGenerator,
  });

  List<GeneratedSchemaComponent> _generatedComponents = [];
  Map<String, DataElement> _mapOfDataElements = {};
  Map<String, ManifestItem> _mapOfManifestItems = {};
  final OpenApi openApi;
  final SchemaMediator schemaMediator;
  final SchemaClassGenerator schemaClassGenerator;

  ContentManifest? generateContentType({
    required String typeName,
    required String subTypeName,
    required String generatedSchemaTypeName,
    required Content? content,
    bool generateToBodyMethod = false,
    bool generateToUriParamMethod = false,
  }) {
    // resseting processed data
    _generatedComponents = [];
    _mapOfDataElements = {};
    _mapOfManifestItems = {};

    // if content is null we cannot create any Type for it
    if (content == null) {
      return null;
    }

    final className = ReCase(typeName).pascalCase;
    _mapOfManifestItems = content.map(
      (contentType, mediaType) {
        final subClassName =
            '${ReCase(subTypeName).pascalCase}${ReCase(_getContentTypeShortName(_fixName(contentType))).pascalCase}';
        final subClassShortName = _fixName(contentType);
        return MapEntry(
          contentType,
          ManifestItem(
            name: subClassName,
            shortName: subClassShortName,
            equality: ManifestEquality.identity,
            fields: [
              _createMediaTypeArguments(
                mediaTypeName: contentType,
                mediaType: mediaType,
                generatedSchemaTypeName: generatedSchemaTypeName,
              ),
            ],
          ),
        );
      },
    );
    final manifest = Manifest(
      name: className,
      items: _mapOfManifestItems.values.toList(),
      params: [],
      fields: [],
    );
    return ContentManifest(
      manifest: manifest,
      extensionMethods: createExtensions(
        className,
        _mapOfDataElements,
        generateToBodyMethod,
        generateToUriParamMethod,
      ),
      generatedComponents: _generatedComponents,
    );
  }

  String createExtensions(
    String parentClassName,
    Map<String, DataElement> content,
    bool generateToBodyMethod,
    bool generateToUriParamMethod,
  ) {
    final buffer = StringBuffer();

    buffer.writeln('\n');
    buffer.writeln('extension ${parentClassName}Ext on $parentClassName{');
    // fromJson method for class Type that is generated by ContentManifestCreator
    for (var entry in content.entries) {
      //TODO(alireza): try using
      var dataElement = entry.value;
      var contentType = entry.key;
      var manifestItem = _mapOfManifestItems[entry.key];
      if (contentType == 'application/json') {
        buffer.writeln('static $parentClassName fromJson(dynamic json) {');
        var manifestField = manifestItem!.fields[0];
        var manifestFieldName = manifestField.name;
        final schemaFromGen = SchemaFromJsonGenerator();
        final application = schemaFromGen.generateApplication(dataElement);
        buffer.writeln('final jsonDeserializer =  $application;');
        buffer.writeln(
          'return $parentClassName.${ReCase(manifestItem.shortName).camelCase}($manifestFieldName: jsonDeserializer(json));',
        );
        buffer.writeln('  }');
      }
    }

    // toJson method for class Type that is generated by ContentManifestCreator

    for (var entry in content.entries) {
      var dataElement = entry.value;
      var contentType = entry.key;
      if (contentType == 'application/json') {
        var returnType = 'dynamic';
        if (dataElement.isObjectDataElement) {
          returnType = 'Map<String,dynamic>';
        } else if (dataElement.isArrayDataElement) {
          returnType = 'List<Map<String,dynamic>>';
        } else {
          returnType = dataElement.type ?? 'dynamic';
        }
        buffer.writeln('$returnType toJson() {');
        final schemaToGen = SchemaToJsonGenerator();
        final application = schemaToGen.generateApplication(dataElement);
        buffer.writeln('final jsonSerializer =  $application;');
        buffer.writeln('final object =  asApplicationJson.applicationJson;');
        buffer.writeln('return jsonSerializer(object);');
        buffer.writeln('  }');
      }
    }
    // fromXml method for class Type that is generated by ContentManifestCreator
    for (var entry in content.entries) {
      // ignore_for_file: unused_local_variable
      var dataElement = entry.value;
      var contentType = entry.key;
      var manifestItem = _mapOfManifestItems[entry.key];
      if (contentType == 'application/xml') {
        //TODO(alireza): implement fromXml later to return a type of $parentClassName
        buffer.writeln('static dynamic fromXml(String xml) {');
        // buffer.writeln('$parentClassName fromXml(String xml) {');

        // var manifestField = manifestItem!.fields[0];
        // var manifestFieldName = manifestField.name;
        // final schemaFromGen = SchemaFromJsonGenerator();
        // final application = schemaFromGen.generateApplication(dataElement);
        // buffer.writeln('final jsonDeserializer =  $application;');
        // buffer.writeln(
        //   'return $parentClassName.${ReCase(manifestItem.shortName).camelCase}($manifestFieldName: jsonDeserializer(json));',
        // );
        buffer.writeln("return '';");
        buffer.writeln('  }');
      }
    }
    // toXml method for class Type that is generated by ContentManifestCreator
    for (var entry in content.entries) {
      var dataElement = entry.value;
      var contentType = entry.key;
      if (contentType == 'application/xml') {
        buffer.writeln('String toXml() {');
        // final schemaToGen = SchemaToJsonGenerator();
        // final application = schemaToGen.generateApplication(dataElement);
        // buffer.writeln('final jsonSerializer =  $application;');
        // buffer.writeln('final object =  asApplicationJson.applicationJson;');
        // buffer.writeln('return jsonSerializer(object);');
        buffer.writeln("return 'fake string xml data';");
        buffer.writeln('  }');
      }
    }
    // getContentType method for class Type that is generated by ContentManifestCreator
    buffer.writeln('String? get contentType {');
    for (var contentType in content.keys) {
      final checkerName =
          'is${ReCase(_fixName(contentType)).pascalCase}'; // like isApplicationJson, isApplicationXml
      buffer.writeln('if ($checkerName) {');
      buffer.writeln("return '$contentType' ;");
      buffer.writeln('}');
    }
    buffer.writeln('else {');

    buffer.writeln("return null ;");
    buffer.writeln('}');
    buffer.writeln('}');

    //generate fromContent method for class Type that is generated by ContentManifestCreator
    buffer.writeln(
        'static $parentClassName fromContentType(String contentType, dynamic data){');
    for (var contentType in content.keys) {
      buffer.writeln("if (contentType == '$contentType') {");
      final methodName = ReCase(_fixName(contentType)).camelCase;
      final argName = methodName;
      final dataElement = content[contentType]!;
      final schemaFromGen = SchemaFromJsonGenerator();
      final application = schemaFromGen.generateApplication(dataElement);
      buffer.writeln('final jsonDeserializer =  $application;');
      buffer.writeln(
          "return $parentClassName.$methodName($argName: jsonDeserializer(data));");
      buffer.writeln('}');
    }
    buffer.writeln(
        "throw Exception('could not create a $parentClassName from contenttype = \$contentType & data =\\n\$data\\n');");
    buffer.writeln('}');
    // body getter method for class Type that is generated by ContentManifestCreator
    if (generateToBodyMethod) {
      buffer.writeln('dynamic toBody() {');
      // todo(alireza): use sealed classes isA & isB to findout the contentType and then use the corresponding method to
      // create the body
      buffer.writeln("return  '';");
      buffer.writeln('}');
    }

    // generate toUriParam method for the class Type that is generated by ContentManifestCreator
    if (generateToUriParamMethod) {
      buffer.write('UriParam toUriParam(String name, bool explode) {');
      buffer.writeln("return UriParam.primitive(name,'');");
      buffer.writeln('}');
    }
    buffer.writeln('}');
    buffer.writeln('\n');

    return buffer.toString();
  }

  ManifestField _createMediaTypeArguments({
    required String mediaTypeName,
    required MediaType mediaType,
    required String generatedSchemaTypeName,
  }) {
    final refOrSchema = mediaType.schema;
    String fieldName = ReCase(_fixName(mediaTypeName)).camelCase;
    late String typeName;
    late bool isNullable;
    if (refOrSchema == null) {
      fieldName = 'value';
      typeName = 'dynamic';
      isNullable = false;
    } else {
      late GeneratedSchemaComponent component;
      if (refOrSchema.isReference) {
        Log.debug(refOrSchema.reference.ref);
        component = getGeneratedComponentByRef(refOrSchema.reference.ref)
            as GeneratedSchemaComponent;
      } else {
        // our schema object first needs to be generated and registered
        component = _createSchemaClassFrom(
          refOrSchema,
          '${ReCase(generatedSchemaTypeName).pascalCase}${ReCase(_getContentTypeShortName(_fixName(mediaTypeName))).pascalCase}'
              .pascalCase,
        );
        _generatedComponents.add(component);
      }
      _mapOfDataElements[mediaTypeName] = component.dataElement;

      typeName = component.dataElement.type!;
      isNullable = component.dataElement.isNullable;
    }

    return ManifestField(
      name: fieldName,
      type: ManifestType(
        name: typeName,
        isNullable: isNullable,
      ),
    );
  }

  GeneratedSchemaComponent _createSchemaClassFrom(
    Referenceable<Schema> schema,
    String name,
  ) {
    var dataElement = schemaMediator.convert(
      openApi: openApi,
      schema: schema,
      name: name,
    );
    if (dataElement is ObjectDataElement) {
      var component = schemaClassGenerator.generate(dataElement);
      return component;
    } else {
      return UnGeneratableSchemaComponent(dataElement: dataElement);
    }
  }

  String _getContentTypeShortName(String contentType) {
    var name = contentType;
    if (contentType == 'application/json') {
      name = 'Json';
    } else if (contentType == 'application/xml') {
      name = 'Xml';
    } else if (contentType == 'multipart/form-data') {
      name = 'Multipart';
    } else if (contentType == 'text/plain') {
      name = 'TextPlain';
    } else if (contentType == 'application/x-www-form-urlencoded') {
      name = 'FormData';
    } else if (contentType == '*/*') {
      name = 'Unknown';
    } else if (contentType.startsWith('image/')) {
      name = 'Image';
    }
    return name;
  }

  String _fixName(String value) {
    return ReCase(value).camelCase.replaceAll('*', '');
  }
}

/// holds the data that can be used by ComponentGenerators to generate components
class ContentManifest {
  ContentManifest({
    required this.manifest,
    required this.extensionMethods,
    required this.generatedComponents,
  });

  final Manifest manifest;
  final String extensionMethods;
  final List<GeneratedComponent> generatedComponents;
}
